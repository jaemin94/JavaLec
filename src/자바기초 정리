 --------------------------------------- 기초 --------------------------------------------------- 
  1. 변수
  	- 자료형	:
  		- 기본자료형
  			- 논리형	: boolean
  			- 문자형	: char
  			- 정수형	: byte, short, int, long
  			- 실수형	: float, double		
  	- 참조자료형	: 기본자료형 외  	
  	- 데이터사이즈	
  			- 1바이트	: boolean, byte
  			- 2바이트	: char, short
  			- 3바이트 : int, float
  			- 4바이트 : long, double
  	- 형변환	:
  		- 자동형변환	: 작은수를 큰 데이터에 넣을때 자동으로 형변환
  		- 명시적형변환	: 큰수를 작은 데이터에 넣을때 앞에 데이터병을 명시적으로 써주는 형변환(실수, 정수 등)
  		- 데이터크기	: byte > short/char > int > long > float > double
  
  2. 연산자
	- 기본연산자	: + - / * %(짝홀수, 배수, 범위, 자리수)
	- 대입연산자 : Lv(공간) = Rv(값)
	- 복합대입연산자 : +=, -=, *=, /=, %=
	- 비교연산자 : >, >=, <, <=, ==, !=
	- 논리연산자 : &&, ||, !
	- 증감연산자 : ++, --
	- 삼항연산자 : (조건식) ? 참 : 거짓
	
	- 비트연산자 
		- 비트 논리 연산자
			- & 	: 두 항의 비트가 모두 1이면 1, 아니면 0으로 연산
			- |		: 두 항의 비트가 모두 0이면 0, 아니면 1로 연산
			- ^		: 두항의 비트가 서로 다르면 1, 같으면 0으로 연산
		- 비트 시프트 연산자
			- >> 	: 왼쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동
			- << 	: 왼쪽 피연산자를 오른쪽 값만큼 비트를 왼쪽으로 이동
			- >>>	: 왼쪽 피연산자를 오른쪽 값만큼 부호 비트를 무시한 채 0 으로 채우면서 오른쪽으로 이동
		-비트 대입 연산자
			- &=	: 두항의 비트가 모두 1이면 1, 아니면 0으로 연산하여 왼쪽 피연산자에 대입
			- |=	: 두항의 비트가 모두 0이면 0 아니면 1로 연산하여 왼쪽 피연산자에 대입
			- ^=	: 두항의 비트가 서로 다르면 1, 같은면 0 으로 연산하여 왼쪽 피연산자에 대입
			- >>=	: 외쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동한후 대입
			- <<=	: 왼쪽 피연산자를 오른쪽 값만큼 비트르 왼쪽으로 이동한 후 대입 
	
  3. 조건문
	- 분기	:	if, Switch
				if(조건식)
				{
					종속코드..
					종속코드..
				}
				if / if - else / if - else - if
					
  4. 반복문	:	while, for  
 
  5. 배열		: 같은 타입의 변수를 연속된 공간에 한번에 선언하는것
  	- 배열 접근방법 
  		- 배열에는 인덱스가 있다. (배열이름[인덱스])
  		- 배열 인덱스는 변수도 사용 가능한다.
  	- 배열 초기화	: 배열 초기화 할때는 for문을 사용하되 변수의 길이를 상수로 직접 적는것보다 length를 사용하는것이 좋다
  				: 반복문으로 하나씩 출력 가능하다.
  				: arrays 클래스의 toString 메서드를 통해 출력 가능하다.
  				: 클래스형 배열을 만들때는 배열 생성은 선언후 초기화 및 값을 입력할때 배열을 다시 선언해줘야한다.
  				: 향상된 포문 
  					- for(int i : arr)
  					- 향상된 포문으로 순차적으로 초기화 시킬수 있다. 
  	
  	- 더 큰큰기의 배열이 필요하다면 arraycopy 함수 사용으로 값을 넘겨 줄수있다.
  		: System.arraycopy(arr,0,temp,arr.length)
  			- arr	: 원본배열명
  			- temp	: 새로 저장될 배열명
  			- arr.length: 복사할 갯수
  		: int arr4[] = Arrays.copyOf(arr1, arr1.length)
  			- arr4 	: 새로운 배열 생성
  			- copyOf: 복사하는 코드
  			- (arr1, arr1.length) : 커피할 기존 배열 , 기존배열의 길이(또는 새로 정수를 입력하여 길이를 정할수있음)
  	
  	- 버블정렬	: 순차적으로 하나씩 자리를 바꿔주면서 순서대로 정렬하는 형식
  		예시	: int[] arr = new int[10];
		
			 for(int i = 0; i<arr.length; i++)
			 arr[i] = (int)(Math.random()*10);
		
			 System.out.println("정렬전: " + Arrays.toString(arr));
		
			 for (int i = 0; i < arr.length - 1; i++) {
            	for (int j = 0; j < arr.length - i - 1; j++) {
                	if (arr[j] > arr[j + 1]) {
                    	int temp = arr[j];
                    	arr[j] = arr[j + 1];
                    	arr[j + 1] = temp;
                	}
            	}
            
        	 }
			 System.out.println("정렬후 : "+ Arrays.toString(arr));
		  	 }

		설명 : 첫 번째 for 루프는 정렬의 패스를 나타냅니다. 배열의 길이 arr.length에서 1을 뺀 값까지 반복합니다. 
				 이는 정렬을 위해 비교할 요소의 범위를 줄여나가기 위함입니다. 
				 각 패스마다 최대 하나의 요소가 제 위치에 정렬되기 때문에 전체 패스 수는 arr.length - 1입니다.
				 두 번째 for 루프는 현재 패스에서 인접한 두 요소를 비교하여 필요한 경우 위치를 교환합니다. 
				 j 변수는 현재 요소의 인덱스를 나타내며, 0부터 arr.length - i - 1까지 반복합니다. 
				 arr.length - i - 1은 현재 패스에서 비교해야 하는 요소의 개수를 나타냅니다. 
				 패스가 진행됨에 따라 큰 값은 배열의 끝으로 이동하므로, 매 패스마다 비교할 요소의 개수는 1씩 줄어듭니다.
				 if 문은 현재 요소 arr[j]와 그 다음 요소 arr[j + 1]를 비교하여 만약 
				 arr[j]가 arr[j + 1]보다 크다면 두 요소의 위치를 교환합니다. 
				 이를 통해 더 큰 값은 오른쪽으로 이동하여 점점 정렬되어가는 구조입니다.
				 위의 과정을 모든 패스에 걸쳐 반복하면 배열이 오름차순으로 정렬됩니다.
				 내림차순으로 변경시 비교연산자를 > 에서 < 으로 변경
  	
  	6. 다차원배열 : 단일 배열이 아닌 여러 데이터칸을 가지고 있는 칸을 생성 
  		- for문을 이용한 2차원 배열 초기화
  			: for(int i[] : arr)
  				for (int j : i)
  			이처럼 향상된 for문을 이중으로 사용한다.
  	7. 가변배열   : 다차원 배열의 각 요소인 1차원 배열의 길이는 달라도 된다
  			예시	: int[][] i = new int[5][] 
  				
 --------------------------------------------------------------------------------------------- 
  1. 객체지향
  	- 존재 사물	: 공간을 차지하는 사물
  	- 인스 턴스	: 객체가 추상화 과정을 통해 자바프로그램 내의 메모리공간에 저장된 상태
  	- 객체 구조	: 속성/기능/생성자
  	- 클래스 		: 객체 생성 위한 자료형
  	- 멤버변수		: 속성,필드 -> 객체의 개별정보 저장용
  	- 멤버메서드	: 기능 -> 액션,동사형, 특정 역할 수행위한 코드블럭
  	- 메서드기본구조: 헤더(반환자료형 함수명 (파라미터..)  )+바디(처리 로직)
  	- 메서드오버로딩: 메서드 파라미터의 형태를 다양하게 둘 수 있도록 허용한 문법
  	- 지역변수		: {} 내에서 선언되는 변수 ,{}벗어나면 기본적으로 소멸 
  	- 메모리구조 	
  			- 스택영역				: {}내에서 선언되는 변수, {} 벗어나면 소멸
  			- 클래스(메서드) 영역	: 공유메모리 영역, static변수, static함수, 멤버변수, 생성자 함수
  			- 힙영역				: 객체 생성시(new 예약어) 메모리 공간 할당, 참조변수 연결해제시 GC(garbage_class)에 의해 제거
  		
  	
 2. 생성자 함수(메서드)
  	- 객체 생성시에 한번 호출되는 특수한 메서드
  	- 객체 생성시에 한번 호출되는 특수한 메서드
	- 객체 생성시에 1회 호출
	- 객체 생성시 필요한 초기값을 부여
	- 생성자 함수는 클래스 이름과 동일하며 반환자료형을 가지지 않는다. 
	- 생성자 함수를 명시하지 않을때 기본적으로 컴파일러에 의해 주입되는 생성자가 있는데 이를 디폴트 생성자라고 한다.
	- 컴파일러에 의해 주입받는 디폴트 생성자는 모든 멤버의 초기값을 '0 or false or null' 로 지정
	- 생성자 오버로딩 : 생성자 함수의 파라미터형을 다양하게 허용함으로써 외부로부터의 다양한 초기값을 허용
	
  3. This 함수
  	- 클래스 내에서 사용되는 예약어
  	- 생성되는 개체의 위치정보(메모리주소) 를 가져오는데 사용
  	- This 활용 : 
  			- 멤버 변수와 매개변수를 구별 : this.x (매개변수) = x (멤버면수);	
  			- 같은 클래스내의 다른 생성자 호출
 
  4. 접근 한정자
  	- public	: 모든 클래스에서 접근가능
  	- defalut	: 동일 패키지에 속한 클래스에서만 접근가능
  	- private	: 동일 패키지 or 상속관계의 하위클래스에서만 접근가능
  	- protected	: 현재 클래스에서만 접근가능
 
  5. Getter , Setter(화면에서 우클릭 > Source > generate getter setter 눌러서 만들수있다.)
  	- Getter = 저장된 값을 불러오는 함수 (리턴 타입을 받는 함수 : int get변수명())
  	- Setter = 지정한 값을 입력하는 함수 (public void 로 리턴타입 없음, 단 리턴을 사용가능. 보통 this로 값을 받아 저장)
  
  6. 캡슐화
  	- 특정 목적을 가지는 기능 구현하는데 있어서 각 과정의 일부나 전부가 외부로의 노출이 불필요한 경우는 정보은닉(Private)을
  	  포함하여 각 과정을 세부기능들의 순서를 지정하여 사용가능한 함수로 지어하는데 이를 캡슐화라고 한다.
  
  7. String 메서드 사용
 	- contain	: 문자열 포함여부
 	- split		: 구분자를 기준으로 문자열을 분할 (배열형으로 저장)
 	- join		: 구분자를 기준으로 문자열을 합친다
 	- trim		: 앞뒤 공백 제거
 	- indexof	: 문자열의 인덱스 번호 확인
 	- substring	: 문자열 자르기
 	- equals	: 문자열의 내용이 같은지 확인
 	
  8. Static
  	- 객체간의 공유되는 변수
  	- 객체 생성과는 무관하게 메모리공간에 할당
  	- 객체 생성없이 클래스명으로 사용가능
  	- 공유함수를 만들게 되면 그 안에서 객체가 생성되기전 없는 멤버 변수를 사용 할 수 없다.
  	
  9. 싱글톤 패턴
  	- 생성자를 private 으로 선언
  	- 외부에서 사용할수있는 반환 메서드 선언
  	- 인스턴스 변수 : 유일한 인트스턴스를 저장하기 위한 정적 변수를 클래스 내부에서 선언
  	- 객체를 지정된 개수만큼 공유한다. 	
  	
 10. 상속
 	- 상속을 사용하는 3가지 이유	: 확장성, 유지보수, 가독성
  	- 만들어 놓은 클래스의 멤버변수 와 멤버 메서드를 다른 클래스에 extends 를 뒤에 붙여 기존 클래스를 상속 받을수있다.
  	- 자식에서 멤버변수 와 멤버 메서드를 만들지 않아도 상속받아 마치 선언해놓은것처럼 사용할수있다.
  	- 받은 하위클래스는 상위클래스의 속성과 기능 이외의 멤벌르 추가할 수 있다.
  	- 부모의 멤버를 가져오는것이 아니라 부모와 별도로 멤버를 생성하는것이다.
  	- 부모가 디폴트생성자가 없다면 자식 또한 디폴트 생성자를 만들어주지 않는다.
  	- 다중 상속은 되지 않는다. 
  	 	
  	- super
 		- 부모로부터 물려받은 멤버변수, 메서드를 가리킬때 사용한다.
 		- 부모로 부터 상속받은 멤버 변수들은 부모의 멤버변수와는 별개로 생성된다.
 		- 부모의 메서드를 오버라이딩 할때도 사용된다.
 		
 	- 오버라이딩(재정의)
 		- 상속받은 부모의 메서드를 물려받은 멤버변수, 메서드를 자식이 새롭게 덮어쓰는 것이다.
 		- 메서드의 이름, 매개변수, 리턴 타입이 일치해야한다.
 		- 리턴이 부모타입일때 자식의 타입으로 변환하여도 오버라이딩으로 인정된다.
 		- 오버라이딩이 아니라면 함수 이름과 매개변수가 같기에 오버로딩으로 분류된다
 		- 오버로딩은 리턴타입을 고려하지 않기에 결국 메서드 중복정의로 해당메서드를 문법적으로 만들 방법이 없다.
 		- static : 인스턴스 메서드의 변환은 불가능하다
 		
 		- 오버로딩과의 차이점
 			- 오버라이딩	: 상속시 부모의 메서드를 덮어쓴다. 시그니처가 동일하다
 			- 오버로딩		: 메서드를 증설한다. 시그니처가 다르다
 			
 	- 다향성
 		- 캐스팅		
 			- 자동형변환
 				- 업캐스팅(자식 이 부모 타입으로 형변환)
 					- 사용하는 이유 : 상속받는 모든객체를 알기위해서 사용한다.
 					- 부모 클래스형의 참조변수 = 자식클래스의 객체
 					- 부모 클래스형의 참조변수를 통해서는 부모 클래스의 속성에만 접근 가능
 					- 자식 클래스는 부모의 모든 정보를 가지고 있기에 자동적으로 형변환이 된다.
 					- 하지만 자식 클래스에서 추가된 메서드, 멤버변수는 사용할수가 없다.
 					- 업캐스팅 되어있으면 오버라이딩을 통해 물려받은 메서드를 변경하여 사용할수있다.
 				
 			- 명시적형변환
 				- 다운캐스팅(부모 가 자식 타입으로 형변환)
 					- 사용하는 이유 : 상속받는 범위외에 확장된 멤버변수, 메서드를 사용하기위해 사용한다.
 					- 부모 클래스는 자식클래스의 모든 정보를 가지고 있기 않기에 객체를 생성할때 명시적으로 형변환을 해야한다.
 					- 자식타입으로 다운캐스팅을 하면 자식 클래스 내의 추가된 메서드, 멤버 변수를 사용할수가 있다.
  	
  			- instanceof
  				- 참조 변수가 가리키는 실제 객체의 타입이 무엇인지 알수 있는 키워드이다.
  				- 사용 할때는 if문 또는 여러개를 한번에 찾아볼 경우에느 if-else 문을 사용한다
  		
  		- 추상 클래스 와 추상 메서드
  			- 사용하는 이유 : 프로그램을 구체적으로 어떻게 구현할지 결정이 되지 않앗거나, 프로그램을 동일한 규격으로 만들수 있도록 가이드를 제공하기 위함
  			- class 앞에 abstract 클래스명으로 정의하여 만들수있다.
  			- 만약 추상 메서드가 있다면 클래스도 반드시 추상클래스로 정의해야된다.
  			- 상위 클래스가 하위 클래스한테 메서드를 쓰라고 강제성을 부여 한다.
  			- 추상 메서드를 하나 이상 포함해야한다.
  				- 추상메서드	: 정의되지 않고 선언만 한 메서드
  				- 예시		: abstract void Func1() , 바디를 만들지 않는다.
  			 			
  			- 추상 클래스는 객체를 생성에 사용되지 않으며 반드시 추상 클래스를 상속받은 클래스를 만드후에
  			  상속받은 모든 추상 메서드를 오버라이딩하여 일반 메서드로 완성한 다음에 객체를 생성할수있다.	
  
  11. 인터페이스
  	- 사용 이유 
  		- 낮은 결합도 유지 				: 다형성 구현에 인터페이스를 사용하여 결합도를 낮춤
  		- 설계 사상을 코딩단계에서 구현		: 인터페이스를 통해 정의한 내용을 코딩단계에서 클래스로 구현되도록 강제 할수있다.
  	- 멤버 메서드가 모두 추상 메서드인 추상클래스
  	- 선언시 class 대신 interface 라고 선언
  	- 인터페이스의 부모는 무조건 인터페이스여야 한다
  		- 인터페이스 vs 추상클래스 
  			- 추상클래스와 다르게 모든 메서드가 추상메서드인다. 
  			- 인터페이스는 내부가 구현된 메서드를 가질수 없다.
  	
  	- 인터페이스는 다중 상속이 가능하다.
  	- 인터페이스를 구현할때 클래스명 뒤에 implements 라는 키워드를 붙이고 그후 사용할 인터페이스를 입력한다.
  	- 인터페이스 구현은 상속과는 별개로 클래스를 상속 받으면서 인터페이스도 사용이 가능하다
  	- 클래스를 상속받으면서 인터페이스를 구현할때는 extends 클래스명 implements 인터페이스명 으로 사용가능하다
  	- Static 메서드는 객체와 무관한 메서드여서 인터페이스에서도 사용이 가능하다
  	- 인터페이스는 구현할때 추상 메서드들을 무조건 구현해야한다.
  	- default 메서드
  		- 인터페이스 특성상 모든 추상메서드를 구현해야하는데 만약에 인터페이스에 추가가 된다면 인터페이스를 사용하는 모든 클래스를
  		  재정의하게 된다. 이를 방지하기 위한것이 default 메서드이다.
  		- 이때 메서드 앞에 default 를 붙이고 줄괄호를 만들어주면서 이 메서드를 사용할 클래스 내에서 재정의를 해주면된다.
  		- 하지만 이러한 코드는 인터페이스 목적과는 맞지않는 코드라 안좋게 볼수도 있다.
  		  
  12. 기본 클래스
  	- Java.lang 패키지	: 기본으로 import 시켜준다
  	- object 클래스		
  		- equals			: 객체의 주소가 서로 같은지 비교하는 함수
  		- HashCode			: 객체를 식별하는 하나의 정수값
  		- identityHashCode	: 실제 객체위치 을 확인하는 함수
  		- clone				: 객체를 복제하는데 사용되는 메서드
  
 	- String 클래스
 		- contain	: 문자열 포함여부
 		- split		: 구분자를 기준으로 문자열을 분할 (배열형으로 저장)
 		- join		: 구분자를 기준으로 문자열을 합친다
 		- trim		: 앞뒤 공백 제거
 		- indexof	: 문자열의 인덱스 번호 확인
 		- substring	: 문자열 자르기
 		- equals	: 문자열의 내용이 같은지 확인
 		- String 클래스는 기본적으로 equals를 오버라이딩하고 있다.
 		- char[] 대신 문자열을 쉽게 다룰수 있는 클래스
 		- StringBuffer 클래스	: 문자열의 수정이 잦을때 활용되는 클래스
 		
 	- System 클래스
  		- 모든 필드와 메서드는 정적필드와 정적메소드로 구성
  			- exit()				: 프로그램 종료
  			- currentTimeMillis()	: 컴퓨터의 시계로부터 현재 시간을 읽어서 밀리세컨드 단위로 리턴
  			- nanoTime()			: 나노세컨드 단위의 long 값 리턴
 		
 	- Wrapper 클래스
 		- 기본형 타입들을 클래스화 한것
 			- boolean	: Boolean
 			- char		: Character
 			- byte		: Byte
 			- short		: Short
 			- int		: Integer
 			- long		: Long
 			- float		: Float
 			- double	: Double
 		- 만든 이유	: 클래스화 하여 다양한 메서드를 제공하기 위함
 		- 제너릭 같이 클래스 타입을 요구할때 사용해야 한다
 		
 	 	- Date 클래스
 		- Calendar 클래스가 나오기 전까지 사용된 클래스
 		- 메서드
 			- getYear	: 년도를 출력
 			- getMonth	: 0 ~ 11까지 출력하므로 뒤에 +1을 더한다
 			- getDay	: 0 ~ 6 으로 출력되며 일 ~ 토 순서이다
 			- getDate	: 날짜를 출력
 			- getHours	: 시간을 출력
 			- getMinutes: 분을 출력
 			- getSeconds: 초를 출력
 		
 	- Calendar 클래스
 		- 날짜와 시간을 다루는 클래스
 		- Calendar 은 객체사 생성 불가하다
 		- 메서드
 			- getInstance	: 기본은 현재 시스템의 시간
 			- YEAR			: 년도를 출력
 			- MONTH	+1		: 0~11 까지 출력하므로 뒤에 + 1을 더한다
 			- DATE			: 날짜를 출력
 			- HOUR			: 시간
 			- MINUTE		: 분
 			- SECOND		: 초
 			- MILLISECOND	: 1000분의 1초
 			- DAY_OF_WEEK	: 1~7 로 출력되며 일 ~ 토 순서이다
 	
 	- Formatter 클래스
 		- SimpleDateFormat	: 날짜 형식을 변경해준다
 			- 객체를 생성후 사용할수있다.
 			- Calendar 객체를 생성후 Date 클래스로 형 변환을 하여 사용할수도 있다.
 				- 바로 SimpleDateFormat 을 생성 하면서 뒤에 ("원하는 형식").format(Date클래스로 형변환한 Cal 객체명)
 				  으로 바로 System.out.println을 사용할수 있다.
 				  - 예 : Calendar cal = Calendar.getInstance();
 				  		 Date date = cal.getTime();
 				  		 System.out.println(new SimpleDateFormat("yyyy-MM-dd").format(date);
 			- format 할때 월 분은 mm 으로 표시되어 월은 대문자 분은 소문자로 표시한다.	  
 	
 	