  1. 변수
  	- 자료형	:
  		- 기본자료형
  			- 논리형	: boolean
  			- 문자형	: char
  			- 정수형	: byte, short, int, long
  			- 실수형	: float, double		
  	- 참조자료형	: 기본자료형 외  	
  	- 데이터사이즈	
  			- 1바이트	: boolean, byte
  			- 2바이트	: char, short
  			- 3바이트 : int, float
  			- 4바이트 : long, double
  	- 형변환	:
  		- 자동형변환	: 작은수를 큰 데이터에 넣을때 자동으로 형변환
  		- 명시적형변환	: 큰수를 작은 데이터에 넣을때 앞에 데이터병을 명시적으로 써주는 형변환(실수, 정수 등)
  		- 데이터크기	: byte > short/char > int > long > float > double
  
  2. 연산자
	- 기본연산자	: + - / * %(짝홀수, 배수, 범위, 자리수)
	- 대입연산자 : Lv(공간) = Rv(값)
	- 복합대입연산자 : +=, -=, *=, /=, %=
	- 비교연산자 : >, >=, <, <=, ==, !=
	- 논리연산자 : &&, ||, !
	- 증감연산자 : ++, --
	- 삼항연산자 : (조건식) ? 참 : 거짓
	
	- 비트연산자 
		- 비트 논리 연산자
			- & 	: 두 항의 비트가 모두 1이면 1, 아니면 0으로 연산
			- |		: 두 항의 비트가 모두 0이면 0, 아니면 1로 연산
			- ^		: 두항의 비트가 서로 다르면 1, 같으면 0으로 연산
		- 비트 시프트 연산자
			- >> 	: 왼쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동
			- << 	: 왼쪽 피연산자를 오른쪽 값만큼 비트를 왼쪽으로 이동
			- >>>	: 왼쪽 피연산자를 오른쪽 값만큼 부호 비트를 무시한 채 0 으로 채우면서 오른쪽으로 이동
		-비트 대입 연산자
			- &=	: 두항의 비트가 모두 1이면 1, 아니면 0으로 연산하여 왼쪽 피연산자에 대입
			- |=	: 두항의 비트가 모두 0이면 0 아니면 1로 연산하여 왼쪽 피연산자에 대입
			- ^=	: 두항의 비트가 서로 다르면 1, 같은면 0 으로 연산하여 왼쪽 피연산자에 대입
			- >>=	: 외쪽 피연산자를 오른쪽 값만큼 부호 비트로 채우면서 오른쪽으로 이동한후 대입
			- <<=	: 왼쪽 피연산자를 오른쪽 값만큼 비트르 왼쪽으로 이동한 후 대입 
	
  3. 조건문
	- 분기	:	if, Switch
				if(조건식)
				{
					종속코드..
					종속코드..
				}
				if / if - else / if - else - if
					
  4. 반복문	:	while, for  
 
  5. 배열		: 같은 타입의 변수를 연속된 공간에 한번에 선언하는것
  	- 배열 접근방법 
  		- 배열에는 인덱스가 있다. (배열이름[인덱스])
  		- 배열 인덱스는 변수도 사용 가능한다.
  	- 배열 초기화	: 배열 초기화 할때는 for문을 사용하되 변수의 길이를 상수로 직접 적는것보다 length를 사용하는것이 좋다
  				: 반복문으로 하나씩 출력 가능하다.
  				: arrays 클래스의 toString 메서드를 통해 출력 가능하다.
  				: 클래스형 배열을 만들때는 배열 생성은 선언후 초기화 및 값을 입력할때 배열을 다시 선언해줘야한다.
  				: 향상된 포문 
  					- for(int i : arr)
  					- 향상된 포문으로 순차적으로 초기화 시킬수 있다. 
  	
  	- 더 큰큰기의 배열이 필요하다면 arraycopy 함수 사용으로 값을 넘겨 줄수있다.
  		: System.arraycopy(arr,0,temp,arr.length)
  			- arr	: 원본배열명
  			- temp	: 새로 저장될 배열명
  			- arr.length: 복사할 갯수
  		: int arr4[] = Arrays.copyOf(arr1, arr1.length)
  			- arr4 	: 새로운 배열 생성
  			- copyOf: 복사하는 코드
  			- (arr1, arr1.length) : 커피할 기존 배열 , 기존배열의 길이(또는 새로 정수를 입력하여 길이를 정할수있음)
  	
  	- 버블정렬	: 순차적으로 하나씩 자리를 바꿔주면서 순서대로 정렬하는 형식
  		예시	: int[] arr = new int[10];
		
			 for(int i = 0; i<arr.length; i++)
			 arr[i] = (int)(Math.random()*10);
		
			 System.out.println("정렬전: " + Arrays.toString(arr));
		
			 for (int i = 0; i < arr.length - 1; i++) {
            	for (int j = 0; j < arr.length - i - 1; j++) {
                	if (arr[j] > arr[j + 1]) {
                    	int temp = arr[j];
                    	arr[j] = arr[j + 1];
                    	arr[j + 1] = temp;
                	}
            	}
            
        	 }
			 System.out.println("정렬후 : "+ Arrays.toString(arr));
		  	 }

		설명 : 첫 번째 for 루프는 정렬의 패스를 나타냅니다. 배열의 길이 arr.length에서 1을 뺀 값까지 반복합니다. 
				 이는 정렬을 위해 비교할 요소의 범위를 줄여나가기 위함입니다. 
				 각 패스마다 최대 하나의 요소가 제 위치에 정렬되기 때문에 전체 패스 수는 arr.length - 1입니다.
				 두 번째 for 루프는 현재 패스에서 인접한 두 요소를 비교하여 필요한 경우 위치를 교환합니다. 
				 j 변수는 현재 요소의 인덱스를 나타내며, 0부터 arr.length - i - 1까지 반복합니다. 
				 arr.length - i - 1은 현재 패스에서 비교해야 하는 요소의 개수를 나타냅니다. 
				 패스가 진행됨에 따라 큰 값은 배열의 끝으로 이동하므로, 매 패스마다 비교할 요소의 개수는 1씩 줄어듭니다.
				 if 문은 현재 요소 arr[j]와 그 다음 요소 arr[j + 1]를 비교하여 만약 
				 arr[j]가 arr[j + 1]보다 크다면 두 요소의 위치를 교환합니다. 
				 이를 통해 더 큰 값은 오른쪽으로 이동하여 점점 정렬되어가는 구조입니다.
				 위의 과정을 모든 패스에 걸쳐 반복하면 배열이 오름차순으로 정렬됩니다.
				 내림차순으로 변경시 비교연산자를 > 에서 < 으로 변경
  	
  	6. 다차원배열 : 단일 배열이 아닌 여러 데이터칸을 가지고 있는 칸을 생성 
  		- for문을 이용한 2차원 배열 초기화
  			: for(int i[] : arr)
  				for (int j : i)
  			이처럼 향상된 for문을 이중으로 사용한다.
  	7. 가변배열   : 다차원 배열의 각 요소인 1차원 배열의 길이는 달라도 된다
  			예시	: int[][] i = new int[5][]
  			
  			
  			